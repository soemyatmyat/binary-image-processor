# -*- coding: utf-8 -*-
"""binaryImageAnalysis_A2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Dr8m6A9ja4Kmu9GLgSO9HDGKvNEIk7dF

## 0. Utilities
"""

# Display Image
import numpy as np
def displayImageWithMatPlot(pixels):
  import matplotlib.pyplot as plt
  plt.imshow(pixels, cmap='gray')
  plt.show()

# Write the pixels to a new file
def generatePGMfrom2DPixelsList(pixels, outfilename, max_gray_value):
    with open(outfilename, "w") as g:
        g.write("P2\n") # tell it is PGM file
        g.write("{} {}\n".format(len(pixels[0]), len(pixels))) # define the width (cols) x heigth (rows)
        g.write("{}\n".format(max_gray_value)) # maximum gray value
        for row in pixels: 
            g.write(" ".join([str(x) for x in row]))
            g.write("\n")

"""## 1. Load Image"""

def readPGMImage(filename):
    with open(filename, "r") as f:
        # Read the first line and check if it's the PGM magic number
        magic_number = f.readline().strip()
        if magic_number != "P2": 
            raise ValueError("Not a PGM file")

        # Read the next line and split it into the width and height of the image
        size = f.readline().strip().split()
        cols = int(size[0]) # width
        rows = int(size[1]) # height

        # Read the next line and use it as the maximum gray value
        max_gray_value = int(f.readline().strip())

        # Read the rest of the file into a list of pixel values
        pixel_raw = [int(x) for x in f.read().strip().split()]
        
        # Get the min value in the pixels
        min_gray_value = min(pixel_raw)

        # Convert the list of pixel values into a 2D list of pixels in the position of pixel = [Row][Column]
        pixels = [pixel_raw[i:i + cols] for i in range(0, len(pixel_raw), cols)]
        return dict(name = filename, cols = cols, rows = rows, max_gray_value = max_gray_value, min_gray_value = min_gray_value, pixels = np.array(pixels))

def loadImage():
    
    while True: # File Prompt
        image_name = input("Enter the image file name (with .pgm) OR 'exit' to quit: ")
        if str(image_name).lower() == 'exit':
            exit()

        if not image_name.endswith(".pgm") and not image_name != 'exit':
            print("Input image is not in PGM format. Please provide a valid PGM image.")
        else:
            try: 
                imgInfo = readPGMImage("%s"%(image_name))
                print(f"\n==== Image Information ====")
                print(f"Name of the file: {imgInfo['name']}")
                print(f"Pixels Dimension (width x height) = {imgInfo['cols']} x {imgInfo['rows']}")
                print(f"Max Gray Value = {imgInfo['max_gray_value']}")
                print(f"Min Gray Value = {imgInfo['min_gray_value']}")
                print(f"Displaying the image...., please close it to proceed.")
                displayImageWithMatPlot(imgInfo["pixels"])
                return imgInfo
            except FileNotFoundError:
                print("File not found. Make sure the file name or file directory path is correct.")

"""## 2. Preprocessing

### Histogram Manipulation
"""

def computeSlopeAndyIntercept(rmin, rmax, imin, imax):
    # Compute the slope using the formula (y2 - y1) / (x2 - x1)
    a = (rmax - rmin) / (imax - imin)
    # Compute the y-intercept using the formula y = mx + b
    b = rmin - (a * imin)
    # Return the values of m and b
    return a, b

def linearStretch(imgInfo, rmin, rmax):
    import numpy as np
    # formula is T(r) = a * r + b, compute a and b from Rmin = a * Imin + b and Rmax = a * Imax + b
    imin = imgInfo['min_gray_value']
    imax = imgInfo['max_gray_value']
    a, b = computeSlopeAndyIntercept(rmin, rmax, imin, imax)
    print("The slope is :", a)
    # out_array = ((imgInfo["pixels"] - imin) * 255 / (imax - imin)).astype('uint8')
    imgInfo["pixels"] = ((a * imgInfo["pixels"]) + b)
    imgInfo["pixels"] = np.clip(imgInfo["pixels"], rmin, rmax).astype('uint8')
    
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "stretch_" + imgInfo["name"], rmax);
    if a > 1: print("\nAfter Linear Stretching of pixels")
    if a < 1: print("\nAfter Linear Compression of pixels")
    if a == 1: print("\nSlope is constant. There is no change to the image")
    return imgInfo

# def linearCompress(imgInfo, rmin, rmax):
#     imin = imgInfo["min_gray_value"]
#     imax = imgInfo["max_gray_value"]
#     a, b = computeSlopeAndyIntercept(rmin, rmax, imin, imax)
#     print("The slope is :", a)
#     # out_array = ((imgInfo["pixels"] - imin) * 255 / (imax - imin)).astype('uint8')
#     imgInfo["pixels"] = ((a * imgInfo["pixels"]) + b).astype('uint8')
#     imgInfo["pixels"] = rmax - imgInfo["pixels"] #this is just inverting
#     generatePGMfrom2DPixelsList(imgInfo["pixels"],  "compress_" + imgInfo["name"], imgInfo["max_gray_value"]);
#     print("\nAfter Linear Compression of pixels")
#     return imgInfo

def powerLawTransform(imgInfo, gamma):
    # formula s = T(r) = c r^r
    # normalize the pixels then power with gamma, then de-normalize the pixels
    imgInfo["pixels"] = (255 * (imgInfo["pixels"] / 255)**gamma).astype('uint8')
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "gamma_" + imgInfo["name"], 255);
    print("\nAfter Non-linear Power Law Transformation of pixels")
    return imgInfo

"""### Smoothing"""

def addpadding(pixels, pad_size):
    h, w = pixels.shape
    padded_img = np.zeros((h + 2 * pad_size, w + 2 * pad_size))
    padded_img[pad_size:-pad_size, pad_size:-pad_size] = pixels
    return padded_img

def convolution(pixels, kernel, pad_size):
    img_h, img_w = pixels.shape
    kernel_h, kernel_w = kernel.shape 
    
    # Create a new array for the output image
    output = np.zeros((img_h, img_w)).astype('uint8')
    
    # Perform the convolution: element-wise multiplication with the kernel
    for i in range(pad_size, img_h-pad_size):
        for j in range(pad_size, img_w-pad_size):
            output[i, j] = np.sum(np.multiply(pixels[i-pad_size:i-1+kernel_h, j-pad_size:j-pad_size+kernel_w], kernel)).astype('uint8')
    
    return output

def medianConvolution(pixels, kernel,pad_size):
    img_h, img_w = pixels.shape
    kernel_h, kernel_w = kernel.shape 
    
    # Create a new array for the output image
    output = np.zeros((img_h, img_w)).astype('uint8')
    
    # Median Convolution
    for i in range(1, img_h-1):
        for j in range(1, img_w-1):
            # Neighborhood of the current pixel
            neighborhood = pixels[i-pad_size:i-1+kernel_h, j-pad_size:j-pad_size+kernel_w]
            # Compute the median value of the neighborhood
            median_value = np.median(neighborhood)
            output[i, j] = median_value
    
    return output

def smoothingAverageMask(imgInfo, kernel_w, kernel_h, pad_size):
    # Edge-handling with padding
    padded_img = addpadding(imgInfo["pixels"], pad_size) 
    
    # Build Average Mask
    kernel = np.ones((kernel_h, kernel_w))
    kernel /= kernel_w * kernel_h
    
    # Convolute
    imgInfo["pixels"] = convolution(padded_img, kernel, pad_size)
    
    # Drop padding
    imgInfo["pixels"] = imgInfo["pixels"][pad_size:-pad_size, pad_size:-pad_size]
    
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "avgMask_" + imgInfo["name"], 255)
    
    print("\nAfter Smoothing with Average Mask")
    return imgInfo

def smoothingWeightedMask(imgInfo, kernel_w, kernel_h, pad_size):
    # Edge-handling with padding
    padded_img = addpadding(imgInfo["pixels"], pad_size) 
    
    # Build Weighted Mask
    kernel = np.ones((kernel_h, kernel_w))
    
    # Calculate the center pixel of the mask
    center_x = kernel_w // 2
    center_y = kernel_h // 2
    
    # Calculate the distance of each pixel from the center
    for i in range(kernel_h):
        for j in range(kernel_w):
            distance = np.sqrt((i - center_y)**2 + (j - center_x)**2)
            kernel[i, j] = 1 / (1 + distance)
    
    # Normalize the mask so that the sum of all elements is 1
    kernel /= np.sum(kernel)
    
    # Convolute
    imgInfo["pixels"] = convolution(padded_img, kernel, pad_size)
    
    # Drop padding
    imgInfo["pixels"] = imgInfo["pixels"][pad_size:-pad_size, pad_size:-pad_size]
    
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "weightedMask_" + imgInfo["name"], 255)
    
    print("\nAfter Smoothing with Weighted Mask")
    return imgInfo

def smoothingMedianMask(imgInfo, kernel_w, kernel_h, pad_size):
    # Edge-handling with padding
    padded_img = addpadding(imgInfo["pixels"], pad_size)
                            
    # Build Weighted Mask: the value doesn't matter 
    kernel = np.ones((kernel_h, kernel_w))
    
    # Convolute
    imgInfo["pixels"] = medianConvolution(padded_img, kernel, pad_size)
    
    # Drop padding
    imgInfo["pixels"] = imgInfo["pixels"][pad_size:-pad_size, pad_size:-pad_size]
    
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "medianMask_" + imgInfo["name"], 255)
    
    print("\nAfter Smoothing with Median Mask")
    return imgInfo

"""## 3. Edge Detection """

def horizontalForwardMask(imgInfo, pad_size):
     # Edge-handling with padding
    padded_img = addpadding(imgInfo["pixels"], pad_size)
    
    # Build Horizontal Forward Mask
    kernel = np.array([[1],[-1]])
    
    # Convolute 
    imgInfo["pixels"] = convolution(padded_img, kernel, pad_size)
    
    # Drop padding
    imgInfo["pixels"] = imgInfo["pixels"][pad_size:-pad_size, pad_size:-pad_size]
    
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "horizontalForward_" + imgInfo["name"], 255)
    
    print("\nAfter Horizontal Forward Mask")
    return imgInfo

def horizontalBackwardMask(imgInfo, pad_size):
     # Edge-handling with padding
    padded_img = addpadding(imgInfo["pixels"], pad_size)
    
    # Build Horizontal Forward Mask
    kernel = np.array([[-1],[1]])
    
    # Convolute 
    imgInfo["pixels"] = convolution(padded_img, kernel, pad_size)
    
    # Drop padding
    imgInfo["pixels"] = imgInfo["pixels"][pad_size:-pad_size, pad_size:-pad_size]
    
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "horizontalBackward_" + imgInfo["name"], 255)
    
    print("\nAfter Horizontal Backward Mask")
    return imgInfo

def horizontalCenteredMask(imgInfo, pad_size):
     # Edge-handling with padding
    padded_img = addpadding(imgInfo["pixels"], pad_size)
    
    # Build Horizontal Centered Mask
    kernel = np.array([[1],[0],[-1]])
    
    # Convolute 
    imgInfo["pixels"] = convolution(padded_img, kernel, pad_size)
    
    # Drop padding
    imgInfo["pixels"] = imgInfo["pixels"][pad_size:-pad_size, pad_size:-pad_size]
    
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "horizontalCentered_" + imgInfo["name"], 255)
    
    print("\nAfter Horizontal Centered Mask")
    return imgInfo

def horizontalPrewittMask(imgInfo, pad_size):
     # Edge-handling with padding
    padded_img = addpadding(imgInfo["pixels"], pad_size)
    
    # Build Horizontal Prewitt-y
    kernel = np.array([[-1,-1,-1],[0,0,0],[1,1,1]])
    
    # Convolute 
    imgInfo["pixels"] = convolution(padded_img, kernel, pad_size)
    
    # Drop padding
    imgInfo["pixels"] = imgInfo["pixels"][pad_size:-pad_size, pad_size:-pad_size]
    
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "horizontalPrewitt_" + imgInfo["name"], 255)
    
    print("\nAfter Horizontal Prewitt")
    return imgInfo

def horizontalSobelMask(imgInfo, pad_size):
     # Edge-handling with padding
    padded_img = addpadding(imgInfo["pixels"], pad_size)
    
    # Build Horizontal Sobel-y
    kernel = np.array([[-1,-2,-1],[0,0,0],[1,2,1]])
    
    # Convolute 
    imgInfo["pixels"] = convolution(padded_img, kernel, pad_size)
    
    # Drop padding
    imgInfo["pixels"] = imgInfo["pixels"][pad_size:-pad_size, pad_size:-pad_size]
    
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "horizontalSobel_" + imgInfo["name"], 255)
    
    print("\nAfter Horizontal Sobel")
    return imgInfo

def verticalForwardMask(imgInfo, pad_size):
     # Edge-handling with padding
    padded_img = addpadding(imgInfo["pixels"], pad_size)
    
    # Build -x centered mask
    kernel = np.array([[1, -1]])
    
    # Convolute 
    imgInfo["pixels"] = convolution(padded_img, kernel, pad_size)
    
    # Drop padding
    imgInfo["pixels"] = imgInfo["pixels"][pad_size:-pad_size, pad_size:-pad_size]
    
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "verticalCentered_" + imgInfo["name"], 255)
    
    print("\nAfter Vertical Forward Mask")
    return imgInfo

def verticalBackwardMask(imgInfo, pad_size):
     # Edge-handling with padding
    padded_img = addpadding(imgInfo["pixels"], pad_size)
    
    # Build -x centered mask
    kernel = np.array([[-1, 1]])
    
    # Convolute 
    imgInfo["pixels"] = convolution(padded_img, kernel, pad_size)
    
    # Drop padding
    imgInfo["pixels"] = imgInfo["pixels"][pad_size:-pad_size, pad_size:-pad_size]
    
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "verticalCentered_" + imgInfo["name"], 255)
    
    print("\nAfter Vertical Backward Mask")
    return imgInfo

def verticalCenteredMask(imgInfo, pad_size):
     # Edge-handling with padding
    padded_img = addpadding(imgInfo["pixels"], pad_size)
    
    # Build -x centered mask
    kernel = np.array([[1,0,-1]])
    
    # Convolute 
    imgInfo["pixels"] = convolution(padded_img, kernel, pad_size)
    
    # Drop padding
    imgInfo["pixels"] = imgInfo["pixels"][pad_size:-pad_size, pad_size:-pad_size]
    
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "verticalCentered_" + imgInfo["name"], 255)
    
    print("\nAfter Vertical Centered Mask")
    return imgInfo

def verticalPrewittMask(imgInfo, pad_size):
     # Edge-handling with padding
    padded_img = addpadding(imgInfo["pixels"], pad_size)
    
    # Build Horizontal Prewitt-x
    kernel = np.array([[-1,0,1],[-1,0,1],[-1,0,1]])
    
    # Convolute 
    imgInfo["pixels"] = convolution(padded_img, kernel, pad_size)
    
    # Drop padding
    imgInfo["pixels"] = imgInfo["pixels"][pad_size:-pad_size, pad_size:-pad_size]
    
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "verticalPrewitt_" + imgInfo["name"], 255)
    
    print("\nAfter Vertical Prewitt")
    return imgInfo

def verticalSobelMask(imgInfo, pad_size):
     # Edge-handling with padding
    padded_img = addpadding(imgInfo["pixels"], pad_size)
    
    # Build Vertical Sobel-x
    kernel = np.array([[-1,0,1],[-2,0,2],[-1,0,1]])
    
    # Convolute 
    imgInfo["pixels"] = convolution(padded_img, kernel, pad_size)
    
    # Drop padding
    imgInfo["pixels"] = imgInfo["pixels"][pad_size:-pad_size, pad_size:-pad_size]
    
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "verticalSobel_" + imgInfo["name"], 255)
    
    print("\nAfter Vertical Sobel")
    return imgInfo

def gradientForwardMask(imgInfo, pad_size):
    imgX = dict.copy(imgInfo)
    imgY = dict.copy(imgInfo)
    gx = horizontalForwardMask(imgX, pad_size)
    displayImageWithMatPlot(gx["pixels"])
    gy = verticalForwardMask(imgY, pad_size)
    displayImageWithMatPlot(gy["pixels"])
    
    # Compute the magnitude of the gradient
    magnitude = np.sqrt(gx["pixels"]**2 + gy["pixels"]**2)
    
    # Normalize from 0 to 255
    min_val = np.min(magnitude)
    max_val = np.max(magnitude)
    imgInfo["pixels"] = ((magnitude - min_val) / (max_val - min_val) * 255).astype(np.uint8)
        
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "forwardGrad_" + imgInfo["name"], 255)
    
    print("\nAfter Forward Gradient")
    return imgInfo

def gradientBackwardMask(imgInfo, pad_size):
    imgX = dict.copy(imgInfo)
    imgY = dict.copy(imgInfo)
    gx = horizontalBackwardMask(imgX, pad_size)
    displayImageWithMatPlot(gx["pixels"])
    gy = verticalBackwardMask(imgY, pad_size)
    displayImageWithMatPlot(gy["pixels"])
    
    # Compute the magnitude of the gradient
    magnitude = np.sqrt(gx["pixels"]**2 + gy["pixels"]**2)
    
    # Normalize from 0 to 255
    min_val = np.min(magnitude)
    max_val = np.max(magnitude)
    imgInfo["pixels"] = ((magnitude - min_val) / (max_val - min_val) * 255).astype(np.uint8)
        
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "backwardGrad_" + imgInfo["name"], 255)
    
    print("\nAfter Backward Gradient")
    return imgInfo

def gradientCenteredMask(imgInfo, pad_size):
    imgX = dict.copy(imgInfo)
    imgY = dict.copy(imgInfo)
    gx = horizontalCenteredMask(imgX, pad_size)
    displayImageWithMatPlot(gx["pixels"])
    gy = verticalCenteredMask(imgY, pad_size)
    displayImageWithMatPlot(gy["pixels"])
    
    # Compute the magnitude of the gradient
    magnitude = np.sqrt(gx["pixels"]**2 + gy["pixels"]**2)
    
    # Normalize from 0 to 255
    min_val = np.min(magnitude)
    max_val = np.max(magnitude)
    imgInfo["pixels"] = ((magnitude - min_val) / (max_val - min_val) * 255).astype(np.uint8)
        
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "centered_" + imgInfo["name"], 255)
    
    print("\nAfter Centered Gradient")
    return imgInfo

def gradientPrewittMask(imgInfo, pad_size):
    imgX = dict.copy(imgInfo)
    imgY = dict.copy(imgInfo)
    gx = horizontalPrewittMask(imgX, pad_size)
    displayImageWithMatPlot(gx["pixels"])
    gy = verticalPrewittMask(imgY, pad_size)
    displayImageWithMatPlot(gy["pixels"])
    
    # Compute the magnitude of the gradient
    magnitude = np.sqrt(gx["pixels"]**2 + gy["pixels"]**2)
    
    # Normalize from 0 to 255
    min_val = np.min(magnitude)
    max_val = np.max(magnitude)
    imgInfo["pixels"] = ((magnitude - min_val) / (max_val - min_val) * 255).astype(np.uint8)
        
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "prewitt_" + imgInfo["name"], 255)
    
    print("\nAfter Gradient Prewitt")
    return imgInfo

def gradientSobelMask(imgInfo, pad_size):
    imgX = dict.copy(imgInfo)
    imgY = dict.copy(imgInfo)
    gx = horizontalSobelMask(imgX, pad_size)
    displayImageWithMatPlot(gx["pixels"])
    gy = verticalSobelMask(imgY, pad_size)
    displayImageWithMatPlot(gy["pixels"])
    
    # Compute the magnitude of the gradient
    magnitude = np.sqrt(gx["pixels"]**2 + gy["pixels"]**2)
    
    # Normalize from 0 to 255
    min_val = np.min(magnitude)
    max_val = np.max(magnitude)
    imgInfo["pixels"] = ((magnitude - min_val) / (max_val - min_val) * 255).astype(np.uint8)
        
    generatePGMfrom2DPixelsList(imgInfo["pixels"],  "sobel_" + imgInfo["name"], 255)
    
    print("\nAfter Gradient Sobel")
    return imgInfo

"""## 4. Main Program"""

def imageProcessingOptions(imgInfo):
    pad_size = 1
    while True: 
        print("\nPlease choose an option to process the image from 1 to 23.")
        print("Note: Operation is irreversible.")
        print("=== Preprocessing ===")
        print("1. Linear Stretching")
        print("2. Linear Compression")
        print("3. Power Law Transformation")
        print("4. Smoothing with Average Mask")
        print("5. Smoothing with Weighted Mask")
        print("6. Smoothing with Median Mask")
        print("=== Horizontal Edge Detection ===")
        print("7. Centered Mask")
        print("8. Forward Mask")
        print("9. Backward Mask")
        print("10. Prewitt")
        print("11. Sobel")
        print("=== Vertical Edge Detection ===")
        print("12. Centered Mask")
        print("13. Forward Mask")
        print("14. Backward Mask")
        print("15. Prewitt")
        print("16. Sobel")
        print("=== Horizontal + Vertical Edge Detection ===")
        print("17. Centered Mask")
        print("18. Forward Mask")
        print("19. Backward Mask")
        print("20. Prewitt")
        print("21. Sobel")
        print("=== Others ===")
        print("22. Load new image")
        print("23. Exit")
        option = input("Enter the number from 1 to 23: ")
        if option.isdigit():
            num = int(option)
            if 1 <= num <= 23:
                if num == 1: # Linear Stretching
                    while True:
                        imin = imgInfo['min_gray_value']
                        imax = imgInfo['max_gray_value']
                        lmin = input("Enter the min pixel value for Linear Stretching (0 - " + str(imin) + "): ")
                        lmax  = input("Enter the max pixel value for Linear Stretching (min - 255): ")
                        if (lmin.isdigit() and lmax.isdigit() and int(lmin) < int(lmax)):
                            imgInfo = linearStretch(imgInfo, int(lmin), int(lmax))
                            break
                        else:
                            print("Min pixel value must be less than max pixel value.")
                elif num == 2: # Linear Compression
                    while True:
                        imin = imgInfo['min_gray_value']
                        imax = imgInfo['max_gray_value']
                        lmin = input("Enter the min pixel value for Linear Compression (" + str(imin) + " - " + str(imax-1) +"): ")
                        lmax  = input("Enter the max pixel value for Linear Compression (min - " + str(imax) + "): ")
                        if (lmin.isdigit() and lmax.isdigit() and int(lmin) < int(lmax)) and int(lmin) >= imin and int(lmax) <= imax:
                            imgInfo = linearStretch(imgInfo, int(lmin), int(lmax))
                            break
                        else:
                            print("Min pixel value must be less than max pixel value.")
                            print("For Compression, the min and max values must be less than image's original min and max which are " + str(imin) + " and " + str(imax) + ".")
                elif num == 3: # Power Law Transformation 
                    while True:
                        gamma = input("Enter the gamma value: ")
                        try:
                            imgInfo = powerLawTransform(imgInfo, float(gamma))
                            break
                        except ValueError:
                            print("Please only enter the digits.")
                elif num == 4: # Smoothing with Average Mask
                    while True:
                        dim = input("Enter the dimension of the mask (e.g. 3x3): ")
                        try:
                            w, h = map(int, dim.split('x'))
                            imgInfo = smoothingAverageMask(imgInfo, w, h, pad_size)
                            break
                        except ValueError:
                            print("Invalid input. Please enter the mask dimension in the format 'width x height'.")
                elif num == 5: # Smoothing with Weighted Mask
                    while True:
                        dim = input("Enter the dimension of the mask (e.g. 3x3): ")
                        try:
                            w, h = map(int, dim.split('x'))
                            imgInfo = smoothingWeightedMask(imgInfo, w, h, pad_size)
                            break
                        except ValueError:
                            print("Invalid input. Please enter the mask dimension in the format 'width x height'.")
                elif num == 6: # Smoothing with Median Mask
                    while True:
                        dim = input("Enter the dimension of the mask (e.g. 3x3): ")
                        try:
                            w, h = map(int, dim.split('x'))
                            imgInfo = smoothingMedianMask(imgInfo, w, h, pad_size)
                            break
                        except ValueError:
                            print("Invalid input. Please enter the mask dimension in the format 'width x height'.")
                elif num == 7: # Horizontal Centered Mask
                    imgIno = horizontalCenteredMask(imgInfo, pad_size)
                elif num == 8: # Horizontal Forward Mask
                    imgIno = horizontalForwardMask(imgInfo, pad_size)
                elif num == 9: # Horizontal Backward Mask
                    imgIno = horizontalBackwardMask(imgInfo, pad_size)
                elif num == 10: # Horizontal Prewit
                    imgInfo = horizontalPrewittMask(imgInfo, pad_size)
                elif num == 11: # Horizontal Sobel
                    imgInfo = horizontalSobelMask(imgInfo, pad_size)
                elif num == 12: # Vertical Centered Mask
                    imgIno = verticalCenteredMask(imgInfo, pad_size)
                elif num == 13: # Vertical Forward Mask
                    imgIno = verticalForwardMask(imgInfo, pad_size)
                elif num == 14: # Vertical Backward Mask
                    imgIno = verticalBackwardMask(imgInfo, pad_size)
                elif num == 15: # Vertical Prewitt
                    imgInfo = verticalPrewittMask(imgInfo, pad_size)
                elif num == 16: # Vertical Sobel
                    imgInfo = verticalSobelMask(imgInfo, pad_size)
                elif num == 17: # Centered Gradient  
                    imgInfo = gradientCenteredMask(imgInfo, pad_size)
                elif num == 18: # Forward Gradient  
                    imgInfo = gradientForwardMask(imgInfo, pad_size)
                elif num == 19: # Backward Gradient  
                    imgInfo = gradientBackwardMask(imgInfo, pad_size)
                elif num == 20: # Gradient Prewitt 
                    imgInfo = gradientPrewittMask(imgInfo, pad_size)
                elif num == 21: # Gradient Sobel
                    imgInfo = gradientSobelMask(imgInfo, pad_size)
                elif num == 22: # Load new image
                    return True 
                elif num == 23: # Exit
                    return False
                displayImageWithMatPlot(imgInfo["pixels"])
            else: 
                print("Please enter the number from 1 to 23 only.")

def main():
  
    # Welcome Message and purpose
    print("\n=====================================")
    print("Welcome to Binary Image Processor")
    print("=====================================")
    print("This a binary image processor.\nUsing this program, user would be able to applly various techniques of image processing to the input image. At present, the program only accepts grey-scaled image, that is, input file must end with PGM extension. \n")
    
    cont = True
    # load the image
    while (cont == True):
        img = loadImage()
        cont = imageProcessingOptions(img)
        
    print("\n==== END ====")

if __name__ == "__main__":
    main()
